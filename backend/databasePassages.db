{"id":2,"locId":2,"passage":" results of a user study comparing drag-and-pop with traditional drag-and-drop on a 15’ (4.50m) wide interactive display wall. Participants where able to file icons up to 3.7 times faster when using the drag-and-pop interface.\n\nKeywords\n\nDrag-and-drop, drag-and-pick, interaction technique, pen input, touchscreen, heterogeneous display.\n\nIntroduction\n\nWith the emergence of pen- and touch-operated personal digital assistants (PDAs), tablet computers, and wall-size displays (e.g., Liveboard, Elrod et al., 1992; Smartboard, http://www.smarttech.com), touch and pen input have gained popularity. Over the past years, more complex display systems have been created by combining multiple such display units. Wall-size touch displays have been combined into display walls, such as the DynaWall (Streitz 2001), or the iRoom Smartboard wall (Johanson, 2002b). Recent PDAs and tablet computers allow connecting additional displays, such as another tablet or a monitor in order to extend the device’s internal display space.\n\n","annotation":"","fileId":1,"startIndex":"7,0","endIndex":"27","startOffset":787,"endOffset":0,"yPosition":0,"_id":"4Ea2rl7hKXVQgMDx"}
{"id":1,"locId":1,"passage":"ce area of the screen and So the surface area of the objects (assumed to be all the same size), and with N denoting the number of displayed objects.\n\nObviously, what is ignored by the system is unnecessary information. Consider the case in which the graphical desktop is entirely tiled with objects, leaving no empty spaces. In that limiting case, we have log2(Ss/So)=log2N. If, however, there are empty spaces, as is the case in many real displays, then the information emitted with the mouse will necessarily exceed that received by the system, and the larger the proportion of empty space in the display, the more bits wasted. So it is the information delivered by cursor motion through the voids of our graphical displays that the system (justly) ignores. Put differently, the continuous input from the hand contains a proportion of gratuitous information. As the cursor crosses an empty region of the display, the system keeps on updating the cursor position to reflect mouse motion. However, this is in","annotation":"","fileId":0,"startIndex":"12,0","endIndex":"13,0","startOffset":813,"endOffset":858,"yPosition":0,"_id":"ViubNzxoZRnHExxK"}
{"id":0,"locId":0,"passage":"cients (b>0) and the expression log2(D/W +1) defining what Fitts termed the index of difficulty (ID). Equation 1 suggests two non-exclusive ways of facilitating target acquisition in a GUI, both of which have been recently investigated in HCI research. One is to reduce D. If, as soon as the system detects cursor motion, it helps by shifting the set of objects that is likely to include the target toward the approaching cursor, the numerator of Equation 1 drops. This is the solution investigated in the Drag-and-Pop technique [4]. Second, the system may expand whatever object is being approached by the cursor, thus increasing W and hence reducing the ID. With this solution, implemented in the Mac OS X Dock,1 performance can be facilitated even if the expansion is very late [14,17].\n\nSemantic pointing [5], a more recent treatment of the pointing facilitation problem, simultaneously attacks the numerator and the denominator of the D/W ratio. The display-control (DC) ratio linking cursor motion to mouse motion is made to depend on cursor position across the landscape of graphical objects: the default DC ratio being set to a high level, each object is surrounded by a ‘well’ of reduced DC ratio. Thus, while mouse amplitude is saved for large cursor motion toward objects (i.e., D is reduced), more amplitude is needed in the vicinity of the target (i.e., W increases). One attractive feature of semantic pointing is that, unlike previous attempts [4, 14], it facilitates performance without the cost of perturbing the visual display. The above solutions do have a potential for facilitating pointing, but they take it for granted that a screen cursor is a tool for pixel selection. Below we question this basic assumption.\n\nInput Information Waste in Current GUIs\n\nThe present study was triggered by the observation that in current GUIs the amount of information received by the system is generally far less than that emitted by the mouse. Consider a graphical desktop with 40 icons, each 20x30 pixel (px) large, on a 1600x1200px screen. Selecting one of these icons means selecting 600px within a set of 1,920,000px, and this amounts to sending log2(1,920,000/600)=11.6 bits to the system. The system, however, just needs the specification of one icon among the 40 icons, that, log240=5.3 bits. So in this example, repre","annotation":"","fileId":0,"startIndex":"9,0","endIndex":"12,0","startOffset":968,"endOffset":556,"yPosition":0,"_id":"nt6R8n58htHpK90X"}
